// Package that contains the models of the JSON objects used in the requests and responses and the methods to create
// new objects that describes the API actions, like the Upload or the AtTokenScraper
package api

import (
	"net/http"
	"fmt"
	"encoding/json"
	"os"
	"bytes"
	"net/url"
	"strings"
	"github.com/simonedegiacomi/gphotosuploader/auth"
	"errors"
	"io"
	"time"
	"io/ioutil"
)

const (
	// Url to which send the request to get a new url to upload a new image
	NewUploadUrl = "https://photos.google.com/_/upload/uploadmedia/rupio/interactive?authuser=2"

	// Url to which send the request to enable an uploaded image
	EnablePhotoUrl = "https://photos.google.com/_/PhotosUi/mutate"

	// (Magic) Key to send in the request to enable the image
	EnablePhotoKey = 137530650

	// Url to move an enabled photo into a specific album
	MoveToAlbumUrl = "https://photos.google.com/u/2/_/PhotosUi/data/batchexecute"
)

// Structure that contains the Upload options
type UploadOptions struct {
	// Required field, a stream from which read the image.
	// You need to close the stream when the image is uploaded
	Stream io.Reader

	// Required field, size of the photo
	FileSize int64

	// Name of the photo (optional)
	Name string

	// UNIX timestamp of the photo (optional)
	Timestamp int64

	// Optional album id
	AlbumId string
}

// Create a new UploadOptions from a file
func NewUploadOptionsFromFile(file *os.File) (*UploadOptions, error) {
	info, err := file.Stat()
	if err != nil {
		return nil, fmt.Errorf("Can't read file information (%v)", err)
	}

	return &UploadOptions{
		Stream:   file,
		FileSize: info.Size(),

		Name:      file.Name(),
		Timestamp: info.ModTime().Unix() * 1000,
	}, nil
}

// Structure that represents an upload, generated by an UploadOptions
type Upload struct {
	// Options of the upload
	Options *UploadOptions

	// Credentials to used to send the requests
	Credentials auth.Credentials

	// URl to which send the request with the image (the real upload)
	url string

	// Id of the image got from the response of the request that enables the image
	enabledImageId string
}

// Create a new Upload given an UploadOptions and a Credentials implementation. This method return an error if the
// upload options struct it's not usable to create a new upload
func NewUpload(options *UploadOptions, credentials auth.Credentials) (*Upload, error) {
	if options.Stream == nil {
		return nil, errors.New("The stream of the UploadOptions is nil")
	}
	if options.FileSize <= 0 {
		return nil, errors.New("The fileSize of the UploadOptions is <= 0")
	}

	// Fill missing optional fields
	if options.Name == "" {
		options.Name = time.Now().String()
	}
	if options.Timestamp < 0 {
		options.Timestamp = time.Now().Unix()
	}

	return &Upload{
		Options:     options,
		Credentials: credentials,
	}, nil
}

// This method tries to upload an image, making multiple http requests
func (u *Upload) TryUpload() error {

	// First request to get the upload url
	err := u.requestUploadUrl()
	if err != nil {
		return errors.New("Can't request an upload url")
	}

	// Upload the real image file
	res, err := u.uploadFile()
	if err != nil {
		return errors.New("Can't upload file")
	}

	// Enable the photo
	_, err = u.enablePhoto(res)
	if err != nil {
		return err
	}

	// Add the image to an album if needed
	if u.Options.AlbumId != "" {
		u.moveToAlbum(u.Options.AlbumId)
	}

	// No errors, image uploaded!
	return nil
}

// Method that send a request with the file name and size to generate an  upload url.
// This method returns the url or an error
func (u *Upload) requestUploadUrl() error {

	// Prepare json request
	jsonReq := RequestUploadURL{
		ProtocolVersion: "0.8",
		CreateSessionRequest: CreateSessionRequest{
			Fields: []interface{}{
				ExternalField{
					External: ExternalFieldObject{
						Name:     "file",
						Filename: u.Options.Name,
						Size:     u.Options.FileSize,
					},
				},


				// Additional fields
				InlinedField{
					Inlined: InlinedFieldObject{
						Name:        "auto_create_album",
						Content:     "camera_sync.active",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name:        "auto_downsize",
						Content:     "true",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name:        "storage_policy",
						Content:     "use_manual_setting",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name:        "disable_asbe_notification",
						Content:     "true",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name:        "client",
						Content:     "photoweb",
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name:        "effective_id",
						Content:     u.Credentials.GetPersistentParameters().UserId,
						ContentType: "text/plain",
					},
				},
				InlinedField{
					Inlined: InlinedFieldObject{
						Name:        "owner_name",
						Content:     u.Credentials.GetPersistentParameters().UserId,
						ContentType: "text/plain",
					},
				},
			},
		},
	}

	// Create http request
	jsonStr, err := json.Marshal(jsonReq)
	req, err := http.NewRequest("POST", NewUploadUrl, bytes.NewBuffer(jsonStr))
	if err != nil {
		return errors.New(fmt.Sprintf("Can't create upload URL request: %v", err.Error()))
	}

	// Add headers for the request
	req.Header.Add("x-guploader-client-info", "mechanism=scotty xhr resumable; clientVersion=156351954")

	// Make the request
	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return errors.New(fmt.Sprintf("Error during the request to get the upload URL: %v", err.Error()))
	}
	defer res.Body.Close()

	// PArse the json response
	jsonResponse := UploadURLRequestResponse{}
	if err := json.NewDecoder(res.Body).Decode(&jsonResponse); err != nil {
		return errors.New(fmt.Sprintf("Can't parse json response for upload URL request: %v", err.Error()))
	}

	if len(jsonResponse.SessionStatus.ExternalFieldTransfers) <= 0 {
		return errors.New("An array of the request URL response is empty")
	}

	// Set the URL to which upload the file
	u.url = jsonResponse.SessionStatus.ExternalFieldTransfers[0].PutInfo.Url
	return nil
}

// This method upload the file to the URL received from requestUploadUrl.
// When the upload is completed, the method updates the base64UploadToken field
func (u *Upload) uploadFile() (*UploadImageResponse, error) {
	if u.url == "" {
		return nil, errors.New("The url field is empty, make sure to call requestUploadUrl first")
	}

	// Create the request
	req, err := http.NewRequest("POST", u.url, u.Options.Stream)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Can't create upload URL request: %v", err.Error()))
	}

	// Prepare request headers
	req.Header.Add("content-type", "application/octet-stream")
	req.Header.Add("content-length", fmt.Sprintf("%v", u.Options.FileSize))
	req.Header.Add("X-HTTP-Method-Override", "PUT")

	// Upload the image
	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Can't upload the image, got: %v", err))
	}
	defer res.Body.Close()

	// Parse the response
	jsonRes := &UploadImageResponse{}
	if err := json.NewDecoder(res.Body).Decode(&jsonRes); err != nil {
		return nil, err
	}
	return jsonRes, nil
}

// Request that enables the image once it gets uploaded
func (u *Upload) enablePhoto(uploadResponse *UploadImageResponse) (*EnableImageResponse, error) {

	// Form that contains the two request field
	form := url.Values{}

	// First form field
	uploadTokenBase64 := uploadResponse.SessionStatus.AdditionalInfo.UploadService.CompletionInfo.CustomerSpecificInfo.UploadTokenBase64
	mapOfItems := MapOfItemsToEnable{}
	jsonReq := EnableImageRequest{
		"af.maf",
		[]FirstItemEnableImageRequest{
			[]InnerItemFirstItemEnableImageRequest{
				"af.add",
				EnablePhotoKey,
				SecondInnerArray{
					mapOfItems,
				},
			},
		},
	}
	mapOfItems[fmt.Sprintf("%v", EnablePhotoKey)] = ItemToEnable{
		ItemToEnableArray{
			[]InnerItemToEnableArray{
				uploadTokenBase64,
				u.Options.Name,
				u.Options.Timestamp,
			},
		},
	}

	// Stringify the first field
	jsonStr, err := json.Marshal(jsonReq)
	if err != nil {
		return nil, err
	}

	// And add it to the form
	form.Add("f.req", string(jsonStr))

	// Second field of the form: "at", which should be an API key or something
	form.Add("at", u.Credentials.GetRuntimeParameters().AtToken)

	// Create the request
	req, err := http.NewRequest("POST", EnablePhotoUrl, strings.NewReader(form.Encode()))
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Can't create the request to enable the image: %v", err.Error()))
	}

	// Add headers
	req.Header.Add("content-type", "application/x-www-form-urlencoded;charset=UTF-8")

	// Send the request
	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Error during the request to enable the image: %v", err.Error()))
	}
	defer res.Body.Close()


	// Read the response as a string
	bytesResponse, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	// Parse the response
	jsonRes := &EnableImageResponse{}
	if err := json.Unmarshal(bytesResponse[6:], &jsonRes); err != nil {
		return nil, err
	}
	u.enabledImageId = jsonRes.getEnabledImageId()

	// Image enabled
	return jsonRes, nil
}


// This method add the image to an existing album given the id
func (u *Upload) moveToAlbum(albumId string) error {
	form := url.Values{}

	var innerJson [2]interface{}
	innerJson[0] = [1]string{u.enabledImageId}
	innerJson[1] = albumId
	innerJsonString, err := json.Marshal(innerJson)
	if err != nil {
		return err
	}

	var jsonReq [1][1][4]interface{}
	jsonReq[0][0][0] = "E1Cajb" // TODO: Extract a significant constant
	jsonReq[0][0][1] = string(innerJsonString)
	jsonReq[0][0][3] = "generic"
	jsonString, err := json.Marshal(jsonReq)
	if err != nil {
		return err
	}

	form.Add("f.req", string(string(jsonString)))
	form.Add("at", u.Credentials.GetRuntimeParameters().AtToken)

	req, err := http.NewRequest("POST", MoveToAlbumUrl, strings.NewReader(form.Encode()))
	if err != nil {
		return errors.New(fmt.Sprintf("Can't create the request to add the image into the album: %v", err.Error()))
	}
	req.Header.Add("content-type", "application/x-www-form-urlencoded;charset=UTF-8")


	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return errors.New(fmt.Sprintf("Error sending the request to move the image: %v", err.Error()))
	}
	defer res.Body.Close()

	// The image should now be part of the album
	return nil
}