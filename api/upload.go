package api

import (
	"net/http"
	"fmt"
	"encoding/json"
	"os"
	"bytes"
	"net/url"
	"strings"
	"gphotosuploader/auth"
	"errors"
	"time"
)

const (
	NewUploadUrl = "https://photos.google.com/_/upload/uploadmedia/rupio/interactive?authuser=2"
	EnablePhotoUrl = "https://photos.google.com/_/PhotosUi/mutate"
)

// Structure that contains the Upload options
type UploadOptions struct {
	FileToUpload *os.File
	Name         string
	Timestamp    int64
	FileSize     int64
}

// Structure that represents an upload, generated by an UploadOptions
type Upload struct {
	Options           *UploadOptions
	Credentials       auth.Credentials
	url               string
}

// Create a new Upload given an UploadOptions and a Credentials implementation to
// get the authenticated http client.
// In the UploadOptions at least the FileToUpload field must not be nil
func NewUpload(options *UploadOptions, credentials auth.Credentials) (*Upload, error) {
	if options.FileSize <= 0 {
		// Read file information to get the file size
		fileInfo, err := options.FileToUpload.Stat()
		if err != nil {
			return nil, errors.New("Can't read stat of the file to upload")
		}
		options.FileSize = fileInfo.Size()
	}
	if options.Name == "" {
		options.Name = options.FileToUpload.Name()
	}
	if options.Timestamp < 0 {
		options.Timestamp = time.Now().Unix()
	}

	return &Upload{
		Options: options,
		Credentials: credentials,
	}, nil
}

// This method tries to upload an image.
// The upload process need 3 different requests, precisely
// 1) The first to get the url to which upload the image
// 2) Real  upload of the image
// 3) Enable the image
func (u *Upload) TryUpload() error {

	// First request to get the upload url
	err := u.requestUploadUrl()
	if err != nil {
		return errors.New("Can't request an upload url")
	}

	// Upload the real image file
	res, err := u.uploadFile()
	if err != nil {
		return errors.New("Can't upload file")
	}

	// Enable the photo
	err = u.enablePhoto(res)
	if err != nil {
		return err
	}

	// No errors, image uploaded!
	return nil
}


// Method that send a request with the file name and size to generate an  upload url.
// This method returns the url or an error
func (u *Upload) requestUploadUrl() error {

	// Prepare json request
	jsonReq := RequestUploadURL{
		ProtocolVersion: "0.8",
		CreateSessionRequest: CreateSessionUploadURLRequest{
			Fields: []interface{}{
				ExternalFieldUploadURLRequest{
					External: ExternalFieldObject{
						Name: "file",
						Filename: u.Options.Name,
						Size: fmt.Sprintf("%v", u.Options.FileSize),
					},
				},
				//InlinedField{
				//	Inlined: InlinedFieldObject{
				//		Name: "sha1",
				//		Content: "0elHPwFYiuiWkbUmPZMx8fFO4RM",
				//		ContentType: "text/plain",
				//	},
				//},
				//InlinedField{
				//	Inlined: InlinedFieldObject{
				//		Name: "upload_media_metadata_base64",
				//		Content: "CAIQARgBIAM465VK",
				//		ContentType: "text/plain",
				//	},
				//},
			},
		},
	}

	// Create http request
	jsonStr, err := json.Marshal(jsonReq)
	req, err := http.NewRequest("POST", NewUploadUrl, bytes.NewBuffer(jsonStr))
	if err != nil {
		return errors.New(fmt.Sprintf("Can't create upload URL request: %v", err.Error()))
	}

	// Add headers for the request
	req.Header.Add("x-guploader-client-info", "mechanism=scotty xhr resumable; clientVersion=156351954")

	// Make the request
	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return errors.New(fmt.Sprintf("Error during the request to get the upload URL: %v", err.Error()))
	}

	// PArse the json response
	jsonResponse := UploadURLRequestResponse{}
	if err := json.NewDecoder(res.Body).Decode(&jsonResponse); err != nil {
		return errors.New(fmt.Sprintf("Can't parse json response for upload URL request: %v", err.Error()))
	}

	if len(jsonResponse.SessionStatus.ExternalFieldTransfers) <= 0 {
		return errors.New("An array of the request URL response is empty")
	}

	// Set the URL to which upload the file
	u.url = jsonResponse.SessionStatus.ExternalFieldTransfers[0].PutInfo.Url
	return nil
}

// This method upload the file to the URL received from requestUploadUrl.
// When the upload is completed, the method updates the base64UploadToken field
func (u *Upload) uploadFile() (*UploadImageResponse, error) {
	if u.url == "" {
		return nil, errors.New("The url field is empty, make sure to call requestUploadUrl first")
	}

	// Create the request
	req, err := http.NewRequest("POST", u.url, u.Options.FileToUpload)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Can't create upload URL request: %v", err.Error()))
	}

	// Prepare request headers
	req.Header.Add("content-type", "application/octet-stream")
	req.Header.Add("content-length", fmt.Sprintf("%v", u.Options.FileSize))
	req.Header.Add("accept-encoding", "gzip, deflate, br")
	req.Header.Add("accept-language", "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4,nb;q=0.2")
	req.Header.Add("x-guploader-no-308", "yes")
	req.Header.Add("x-http-method-override", "PUT")
	req.Header.Add("dnt", "1")


	// Upload the image
	res, err := u.Credentials.GetClient().Do(req)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Can't upload the image, got: %v", err))
	}

	// Parse the response
	jsonRes := &UploadImageResponse{}
	if err := json.NewDecoder(res.Body).Decode(&jsonRes); err != nil {
		return nil, err
	}
	return jsonRes, nil
}

// Request that enables the image once it gets uploaded
func (u *Upload) enablePhoto(uploadResponse *UploadImageResponse) error {

	// Form that contains the two requewt field
	form := url.Values{}

	// First form field
	uploadTokenBase64 := uploadResponse.SessionStatus.AdditionalInfo.UploadService.CompletionInfo.CustomerSpecificInfo.UploadTokenBase64
	jsonReq := EnableImageRequest{
		"af.maf",
		[]FirstItemEnableImageRequest{
			[]InnerItemFirstItemEnableImageRequest{
				"af.add",
				137530650,
				SecondInnerArray{
					MapOfItemsToEnable{
						"137530650": ItemToEnable{
							ItemToEnableArray{
								[]InnerItemToEnableArray{
									uploadTokenBase64,
									u.Options.Name,
									1497707665000,
								},
							},
						},
					},
				},
			},
		},

	}
	// First field of the form: "f.req"
	//arrayG := []interface{}{uploadtokenBase64, u.Options.Name, 1497707665000}
	//arrayF := []interface{}{arrayG}
	//arrayE := []interface{}{arrayF}
	//objectA := map[string]interface{}{"137530650": arrayE}
	//arrayD := []interface{}{objectA}
	//arrayC := []interface{}{"af.add", 137530650, arrayD}
	//arrayB := []interface{}{arrayC}
	//arrayA := []interface{}{"af.maf", arrayB}

	// Stringify the first field
	jsonStr, err := json.Marshal(jsonReq)
	if err != nil {
		panic(err)
	}

	// And add it to the form
	form.Add("f.req", string(jsonStr))


	// Second field of the form: "at", which should be an API key or something
	// TODO: Get the key dynamically
	form.Add("at", "AKP94S1qFuWxy_Suk6fw2DyabTK2g3SaWA:1497883978124")


	// Create the request
	req, err := http.NewRequest("POST", EnablePhotoUrl, strings.NewReader(form.Encode()))
	if err != nil {
		return errors.New(fmt.Sprintf("Can't create the request to enable the image: %v", err.Error()))
	}

	// Add headers
	req.Header.Add("content-type", "application/x-www-form-urlencoded;charset=UTF-8")

	// Send the request
	_, err = u.Credentials.GetClient().Do(req)
	if err != nil {
		return errors.New(fmt.Sprintf("Error during the request to enable the image: %v", err.Error()))
	}

	// Image enabled
	return nil
}
